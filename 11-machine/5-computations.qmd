---
references:
    - id: teylor
      url: https://mathworld.wolfram.com/TaylorSeries.html
      title: Taylor Series
---

# Приближенные вычисления

## Ряды Тейлора

Любую гладкую функцию $f(x)$ можно разложить в ряд Тейлора @teylor, предварительно выбрав некоторое значение аргумента $x = a$. Точка $a$ и соответствующее ей значение функции $f(x = a)$ становятся центральными для всего разложения. Ряд Тейлора --- это степенной ряд, в котором исходная функция $f(x)$ представляется в виде суммы по степеням отклонений $\Delta x$ от точки $a$. Первый член ряда $f(a)$ определяет значение, к которому добавляются степенные поправки:
$$
\begin{aligned}
f(x) &= \hi{f(a)} + f'(a) (\ub{x - a}_{\Delta x}) + \dfrac 1 2 f''(a) (x - a)^2 + \dfrac 1 6 f'''(a) (x - a)^3 + O(x^4) = \\
     &= \sum_{n=0}^m \dfrac{f^{(n)}(a)}{n!} (x - a)^n + O(x^{m+1}), 
\end{aligned}
$${#eq-teylor}
где $f^{(n)}(x) = \dv[n]{f}{x}$ --- $n$я производная^[0я производная совпадает с исходной функцией], $O$ --- порядок малости [TODO]. При $a = 0$, ряд Тейлора называют *рядом Маклорена*.

Разложение в ряд Маклорена используется для вычисления значений элементарных функций: тригонометрических, экспоненциальных, логарифмов идр. Процессор компьютера или калькулятора естественным образом работает с битами --- лишь простейшие арифметические операций могут быть реализованы в кремнии, значение полинома как раз можно рассчитать с их помощью. Если функция раскладывается в ряд, её можно вычислить на компьютере стандартными средствами машинной арифметики. Полиномиальные выражения, содержащие заранее рассчитанные коэффициенты, без труда могут быть включены в код программы.

```python
def func(x):
    return 10 - 20 * x + 30 * x ** 2 - 40 * x ** 3
```

Ряды --- универсальный подход, в конкретных случаях могут использоваться нетривиальные алгоритмы, эксплуатирующие математические свойства вычисляемого выражения или специальные возможности процессоров. Иногда набор предварительно вычисленных значений можно хранить в памяти и использовать непосредственно или для интерполяции на промежутончые точки.

### Вычисление экспоненты

Рассчитаем таблицу производных функции $f(x) = e^x$ и их значения в точке $a = 0$.

```{python}
import sympy as sp
from sympy.abc import x
import pandas as pd

def derivative_table(expr, a, n_max=4):
    df = pd.DataFrame(
        [(n, expr.diff(x, n), expr.diff(x, n).subs({x: a})) for n in range(n_max + 1)]
    )

    df.rename(columns={0: '$$n$$', 1: '$$f^{(n)} (x)$$', 2: '$$f^{(n)} (x = a)$$'}, inplace=True)
    df.style.hide(axis='index')
    df = df.applymap(lambda s: '$$' + sp.latex(s) + '$$')
    return df

expr = sp.exp(x)
a = 0

derivative_table(expr, a, n_max=2)
```

Закономерность ясна. Подставим значения производных и $a$ в @eq-teylor, получим разложение $e^x$ в ряд Тейлора вблизи $x = a = 0$:

$$
e^x = e^0 + \dfrac 1 {1!} x + \dfrac 1 {2!} x^2 + \dfrac 1 {3!} x^3 + \dfrac 1 {4!} x^4 + \dfrac 1 {5!} x^5 + O(x^5).
$$

Построем выражения, содержащие только первые члены полученного ряда.

```{python}
def plot_series(expr, var, ns):
    polys = [sp.series(expr, x, n=n).removeO() for n in ns]
    sp.plot(expr, *polys, (x, -sp.pi, sp.pi), legend=True)

plot_series(expr, x, [1, 2, 3, 4, 5, 6])
```

С увеличением числа слагаемых растёт точность описания $e^x$. 

### Вычисление синуса

Таблица производных $f(x) = \sin x$. 

```{python}
expr = sp.sin(x)
a = 0
derivative_table(expr, a)
```

Поскольку $\sin^{(4)} x \equiv \sin x$, выражения производных будут чередоваться: $\sin^{(5)} x = \sin^{(1)}(x)$ итд. 

Подставим значения производных и $a$ в @eq-teylor, получим разложение $\sin x$ в ряд по $х$ вблизи $a = 0$:
$$
\begin{aligned}
\sin x &= \sin 0 + \dfrac{1}{1!} x + 0 \cdot x^2 + \dfrac{-1}{3!} x^3 + 0 \cdot x^4 + \dfrac 1 {5!} x^5 + 0 \cdot x^6 + \dfrac{-1}{7!} x^7 + 0 \cdot x^8 + O(x^9) = \\
&= x - \dfrac{x^3}{3!} + \dfrac{x^5}{5!} - \dfrac{x^7}{7!} + O(x^9).
\end{aligned}
$$

Построем выражения, состоящие из первых членов полученного ряда.

```{python}
plot_series(sp.sin(x), x, [2, 4, 6, 8])
```

С увеличением числа слагаемых полином всё лучше приближает $f(x) = \sin x$. Вычисление синуса «по определению» (через отношение сторон треугольника) невозможно реализовать в процессоре простыми средствами.

---

Разложение в ряд используется не только для вывода численных аппроксимаций функций, но и для получения аналитических соотношений.

### Уравнение движения

Пусть одномерная траектория тела описывается гладкой функцией --- координатой $x(t)$, разложим её в ряд Тейлора (@eq-teylor):

$$
x(t) = x(t=0) + \dot x (t=0) \cdot t + \dfrac 1 2 \ddot x(t=0) \cdot t^2 + \dfrac 1 6 \dddot x(t=0) \cdot t^3 + O(t^4),
$${#eq-kin}
где точкой обозначена соответствующая производная по времени. Дадим интерпретацию коэффициентам:

1. $x_0 = x(t=0)$ --- **начальная** координата, аналогично:
2. $v_0 = \dot x(x=0)$ --- скорость, 
3. $a_0 = \ddot x(е = 0)$ --- ускорение,
4. $j_0 = \dddot x(t = 0)$ --- рывок,
5. $O(t^4)$ --- члены более высоких порядков.

При движении с постоянной скоростью, ускорение отсутствует ($a(t) = 0$), члены $O(t^2)$ обнуляются:
$$
x(t) = x_0 + v_0 t,
$$
если тело движется с постоянным ускорением, отсутствует рывок ($j(t) = 0$):
$$
x(t) = x_0 + v_0 t + \dfrac{a_0 t^2}{2}.
$$

Законы кинематики были открыты в эксперименте, однако, ряды позволяют проиллюстрировать, что формулы для частных случаев движения являются следствием более общего закона: в движении реального тела члены высших порядков играют свою роль.

### Гармонический осциллятор

Применим ряд Тейлора для описания колебания тела на пружине. При деформации пружины длины $\bar l$ в ней запасается потенциальная энергия $U$, которая стремится вернуть её к исходной длине. Чем больше длина $l$, тем больше эта энергия. Разложим $U(l)$ в ряд Тейлора:
$$
U(l) = U(\bar l) + U'(\bar l) (\ub{l - \bar l}_{\Delta l}) + \dfrac 1 2 U''(\bar l) (l - \bar l)^2 + O(l^3),
$$ 
длина $\bar l$ недеформированной пружины выбрана в качестве центрального $a$ при разложении по @eq-teylor.  

Обсудим каждый коэффициент:

1. $U(\bar l)$ --- поскольку выбор потенциала произволен, эту константу можно принять равным нулю;
2. в точке $l = \bar l$ деформация $\Delta l = 0$, значит запас потенциальной энергии минимален:
    $$U(l = \bar l) = \min U,$$
    в точке минимума производная $U'(l = \bar l) = 0$ --- это второй коэффициент;
3. $U''(\bar l)$ обозначим как $k$;
4. отклонение пружины $\Delta l$ от центральной точки разложения $\bar l$ мало, то хорошего описания $U$ можно добиться первыми слагаемыми ряда, поэтому пренебрежём членами высших порядков $O(t^3)$. 

В результате получим закон Гука: 
$$
U(\Delta l) = \dfrac 1 2 k \Delta^2 l,
$$
где $k$ --- константа жёсткости пружины. 

Если отклонение осциллятора от положения равновесия достаточно большие, членами $O(t^3)$ пренебречь нельзя, и рассуждения перестают работать. Закон Гука был получен экспериментально, ряды дают его теоретическое объяснение.
