---
references:
    - id: riscv-instructions
      title: RISC-V Instruction-Set Cheatsheet
      url: https://itnext.io/risc-v-instruction-set-cheatsheet-70961b4bbe8
    - id: rescv-interpreter
      title: RISC-V Interpreter
      url: https://www.cs.cornell.edu/courses/cs3410/2019sp/riscv/interpreter/
    
---

# Машинный код

### Системы команд

Процессор может исполнять только ограниченный набор инструкций, они аппаратно реализованны в кремнии. Ни одна программа не способна обойти законы физики и добавить к процессору новые инструкции. От этого набора зависит логика работы любой программы на самом низком уровне и производительность компьютера в целом. В современных компьютерах конкурируют 2 системы команд:

CISC
: (Complicated Instruction Set Computer) --- *полная* система команд, появилась из желания решить проблему медленной RAM: чем реже процессору нужно обращаться в память, тем быстрее будет работать компьютер.  Решение CISC --- это реализовать в процессоре большой набор инструкций (1000+), в результате:

    - процессор умеет производить комплексные операции с регистрами и не хранит промежуточные вычисления в памяти;
    - программы занимают мало места в памяти из-за того, что содержат меньше инструкций.

    В CISC --- опткод операции может быть переменной длины, а инструкции могут выполняться за несколько тактов, т/е процессор обращается к памяти через большие промежутки, во время которых он занимается делом.
    
    Проблема заключается в сложности: для создания замысловатой логики требуются большое число транзисторов и затейливая топология их соединения. Такие процессоры сложны в производстве, подвержены браку и, следовательно, дороже.

RISC
: (Reduced Instruction Set Computer) --- *сокращенная* система команд, появилась как ответ на переусложнение CISC на фоне снижения цен на память RAM и её ускорения: далеко не все команды CISC используются часто, избавившись от их груза можно упросить схему процессора. RISC-процессоры поддерживают небольшой набор простых инструкций (~200), что приводит к увеличению размера программы и более частым обращениям к памяти. Каждая команда исполняется за 1--2 такта, длина опткода --- фиксирована. Из-за меньшего числа транзисторов, процессор потребляет меньше энергии и слабо греется, поэтому RISC используется в большинстве мобильных устройств.

При прочих равных, CISC-процессоры оказываются производительнее RISC, однако с появлением многоядерности и уменьшения размера элементов, на первое место вышла простота организации транзисторов на кристалле --- производительность RISC процессоров сравнялась с CISC при меньшем энергопотреблении. 

### Архитектуры процессоров

Архитектуру процессора определяют:

- набор типов данных, с которыми работает процессор;
- набор исполняемых им машинных команд;
- набор регистров, к которым программист имеет доступ.

Выделим 3 архитектуры:

x86
: CISC-архитектура, изначально разработанная Intel в конце 70х, оперирует 32-разрядными адресами.

x86-64
: CISC-архитектура, появилась в 00х, когда стало понятно, что 32-разрядная адресация себя исчерпала, изначально разработана AMD. Поддерживает 64-разрядные адреса.

ARM
: RISC-архитектура, представленная в 80х, изначально использовалась в низкопроизводительных процессорах. Сейчас конкурирует с другими архитектурами везде, поддерживает 32- и 64-разрядные адреса.

## Ассемблер

Помимо данных, RAM хранит инструкции для процессора в битовом представлении. Формат хранения этих *машинных инструкций* называется *машинным кодом* @machine-code. Одна машинная инструкция состоит из *опткода* (двоичного *кода операции*) и *операнда*, но последнего может не быть, если операция не принимает никаких параметров. Опткод и операнд записаны в памяти один за другим. Пока компьютер работает, процессор циклически обращается к RAM за следующей инструкцией, интерпретирует опткод, осуществляет операцию с операндами и затем запрашивает новую инструкцию. Цикл останавливается, когда прекращается питание.

Чтобы не писать программы на машинном коде, был создан *язык ассемблера* (англ. assembly language --- язык сборки), он предоставляет доступ к инструкциям процессора, но не через бинарные опткоды, номера ячеек и регистров, а через их символьные сокращения, например, инструкция `ADD r1, r2` сложит числа в регистрах `r1` и `r2`.

Машинный код содержит инструкции для конкретного процессора, поэтому аппаратно-зависим. Написанные на ассемблере инструкции однозначно транслируется в машинный код, поэтому код на ассемблере может выглядеть по-своему для каждого процессора, т/е разные диалекты ассемблера нужны для процессоров с разным набором команд. Поскольку код на ассемблере позволяет избегать использования машинных кодов, одну программу можно транслировать в *разные машинные коды* для совместимых между собой процессоров.

::: {.callout-note collapse="true"}

## Сложение чисел на CISC-процессоре

Фрагмент кода на ассемблере, вызывающий машинные команды для сложения 2 чисел и записи результата в оперативную память. Синтаксис зависит от диалекта ассемблера.

```assembler
# 1 + 2 -> 3 -> RAM

MOV r0, 8 # записать в регистр r0 число 8 (адрес)
MOV r1, 1 # записать в регистр r1 число 1
MOV r2, 2 # записать в регистр r2 число 2

ADD r1, r2 # сложить числа в регистрах r1 и r2, записать результат в r1
STR r1, [r0] # записать сумму из r1 в ячейку памяти, взяв адрес из регистра r0
```
:::

::: {.callout-note collapse="true"}

## Сложение чисел на RISC-процессоре

RISC-V --- открытая архитектура процессоров, поддерживающая систему команд RISC.

```assembler
# регистры процессора с архитектурой RISC-V пронумеровны x1, x2, ..., x32
# для простоты, значения x поделены на диапазоны, например:
# регистры x10, ..., x18 обозначают a0, ..., a7

# x0, x1, ..., x10, x11, ..., x18, x19, ...
#               a0,  a1, ...,  a7.

# регистр x0 хранит константу --- аппаратный 0, её нельзя изменить.
# поскольку значение хранится в байтах, 0 = 00000000

# RISC-V не имеет команды прямой записи значения в регистр процессора,
# чтобы записать число 1 в регистр a0, необходимо сложить
# его со значением из x0 и записать результат в a0
ADDI a0, x0, 1 # 👈 a0 <- 0 + 1

# запишем число 2 в регистр a1
ADDI a1, x0, 2 # 👈 a1 <- 0 + 2

# теперь в регистрах процессора находятся двоичные числа,
# каждое закодировано одним байтом:
# регистр a0 = 00000001, регистр a2 = 00000010

# сложим числа в регистрах a0 и a1, результат запишем в регистр a2
ADD a2, a0, a1 # 👈 a2 <- a0 + a1

# для копирования значения из регистра процессора в ячейку оперативной памяти
# необходимо указать её адрес, однако, одна команда процессора используется для
# записи и по конкретному адресу, и по относительным к нему адресам, поэтому
# требуется явно указывать абсолютный адрес и число 0 в качестве относительного

# сохраним результат суммирования из регистра a2 в ячейку оперативной памяти по
# абсолютному адресу 4 и относительному к нему x0 = 0, те значение будет сохранено
# в ячейку 4 + 0 = 4
SB a2, 4(x0) # 👈 memory[4 + 0] <- a2

# в результате мы сложили числа 1 и 2 и записали сумму в 4ю ячейку оперативной
# памяти
```
:::

## Микрокод

Если обрабатываемые данные помещаются в машинное слово, для сложения двух целых чисел процессору требуется 1 такт, а для их умножения --- обычно не больше 3. Для деления дробных чисел может потребоваться 50+ тактов. Простые операции (например, сложение) формально могут выполняться за доли одного такта: существуют *векторные инструкции*, которые за раз складывают несколько чисел, т/е исполняют операции параллельно.

Современные процессоры обросли функциональностью и стали *системами на кристалле*, они выполняют специфические операции, которые ускоряют шифрование, работу с графикой, нейронными сетями итд. Не все CISC команды процессора реализованы аппаратно, некоторые лишь эмулируются. Простой RISC-процессор может работать, эмулируя сложные команды CISC-процессора. 

Ранние x86 процессоры действительно поддерживали CISC-команды, однако, современные x86-64 процессоры аппаратно являются RISC-процессорами, но совместимы с CISC благодаря эмуляции. Одна CISC-команда может выполняться сотнями команд в RISC-процессоре. Команды, исполняемые для эмуляции сложной инструкции, называют *микрокомандами* или *микроинструкциями*. 

Эмуляцию сложной команды можно реализовать разными последовательностями микрокоманд. Серия микрокоманд называется *микропрограммой*, набор микропрограмм --- *микрокодом*. Микрокод процессора не существует аппаратно, он хранится в памяти и его можно менять, эмулируя добавление новых команд процессора. Это позволят процессору исполнять код, скомпилированный для архитектуры с другим набором инструкций, но с потерей производительности. Найденные в процессорах уязвимости также могут устраняться патчами микрокода.

## Трансляция

Написание кода на ассемблере --- сложное дело, программисты предпочитают использовать более высокоуровневые языки. Программу, преобразующую код на высокоуровневом языке в машинный язык, называют *компилятором*. К компилируемым языкам относятся C, C++, Rust идр. Компилятор не всегда генерирует оптимальный машинный код, но предоставляет более простой интерфейс к ресурсам компьютера. Программы, написанные на компилируемых языках, распространяются в виде машинного кода для разных платформ.

Машинный код не переносим между разными семействами процессоров, поэтому некоторые языки программирования компилируются в *байт-код* --- машинный код для некоторой *виртуальной машины*. Это программа, которая эмулирует логику работы компьютера на низком уровне: принимает инструкции и данные, и затем преобразует их в машинные инструкции для физического процессора. Виртуальную машину можно единожды реализовать подо все архитектуры процессоров, и исполнять один байт-код везде без изменений.

Существуют языки программирования, программы на которых исполняются как последовательность инструкций с помощью специальной программы --- *интерпретатора*, например, интерпретатор языка JavaScript встроен в браузеры, он нужен для работы многих современных сайтов. Самому интерпретатору не обязательно даже генерировать машинный код, он может исполнять инструкции буквально сам: разработчик интерпретатора реализует как интерпретатор реагирует на команды, в результате вся логика работы содержится в машинном коде интерпретатора. Программы на интерпретируемых языках распространяются в виде исходных кодов --- инструкций для интерпретатора.

Преобразование программы между разными формальными представлениями (высокоуровневый код, байт-код, машинный код, команды для интерпретатора) называют *трансляцией*. Язык программирования --- это правила синтаксиса (ключевые слова, конструкции `if`-`else`, итл). Способ трансляции и исполнения программы может быть каким угодно. Например, для языка Java реализованы и виртуальная машина, и компилятор, и интерпретатор. В реальности разграничивать эти понятия бессмысленно: Java-код компилируется в байт-код для виртуальной машины, которая работает в режиме интерпретатора или в режиме компилятора.

::: callout-note
Виды трансляции:

компиляция
: в машинный код --- программа преобразуется в машинный код (машинные инструкции).
: в байт-код --- программа преобразуется в машинные инструкции для виртуальной машины.

интерпретация
: код интерпретируется как набор команд и исполняется последовательно программой интерпретатором.
:::

## «Интерпретатор» Python

Деление языков на интерпретируемые и компилируемые --- условно. Язык Python называют интерпретируемым: стандартная реализация Python написана на языке C и называется CPython, это интерпретатор, который транслирует каждый раз при запуске программы, т/е код не хранится и не распространяется в виде машинного или байт-кода. Python-код исполняется гибридным интерпретатором, внутри которого 3 транслятора:

парсер
: преобразует текст программы в абстрактное синтаксическое дерево AST (Abstract Syntax Trees) --- иерархическое представление кода (ключевых слов, функций, аргументов, операторов итд) в виде графа;

компилятор
: преобразует AST в байт-код;

виртуальная машина
: программа, которая исполняет байт-код без явного преобразования в машинный код, а сама является выполняющейся на процессоре программой.

Кроме этого, в состав интерпретатора CPython включён лексический анализатор, который проверяет синтаксическую корректность программы до преобразования в AST.

Интерпретатор Python позволяет получать доступ 

```
text = 'y = 2 * x + 3'
tree = ast.parse(text)
ast.dump(tree)
```

```
bytecode = compile(tree, '<string>', 'exec')
exec(bytecode)
x = 10
exec(bytecode)
y
```